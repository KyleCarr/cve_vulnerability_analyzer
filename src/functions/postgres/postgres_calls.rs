

extern crate diesel;


use std::collections::HashMap;
use crate::functions::postgres::models::*;
use diesel::prelude::*;
use diesel::pg::{ PgConnection};
use std::string::String;

use crate::schema::cve::dsl::cve;
use crate::schema::cve::table;


fn init() ->PgConnection {

    let settings = config::Config::builder()
        .add_source(config::File::with_name("src/config/config.json"))
        .build()
        .unwrap();

    let postgres_username = settings.get_string("postgres_username").unwrap();
    let postgres_password = settings.get_string("postgres_password").unwrap();
    let postgres_host = settings.get_string("postgres_host").unwrap();
    let postgres_db = settings.get_string("postgres_db").unwrap();
    let postgres_url = format!("postgres://{}:{}@{}/{}", postgres_username, postgres_password, postgres_host,  postgres_db);
    let connection = PgConnection::establish(&postgres_url).unwrap();
        //TODO: load db connection as environment variables
       // let connection = PgConnection::establish("postgres://docker:password@localhost/postgresdb").unwrap();
    return connection;
    }

    pub fn post( _name: String, _product: String, _version: String, _description: String, _resources: Vec<String>){
        let db_connection = &mut init();

        let post = create_post(db_connection, _name, _product, _version, _description,_resources);
        println!("post created with id {}", post.id);
    }

    fn create_post(conn: &mut PgConnection,  name: String, product: String, version: String, description: String, resources: Vec<String>) -> Post {
    use crate::schema::cve;


    let new_post =  NewPost {  name, product, version, description, resources};

    diesel::insert_into(cve::table)
        .values(&new_post)
        .returning(Post::as_returning())
        .get_result(conn)
        .expect("Error saving new post")

}

pub fn set_filter(_name: Vec<String>, _description: Vec<String>) -> HashMap<String, String> {
    let db_connection = &mut init();

    let filter = get_filter(db_connection, _name, _description);
    return filter;
}
pub fn examine_cve(_name: String) {
    use diesel::prelude::*;
    use crate::schema::cve::dsl::*;
    let db_connection = &mut init();
    let mut query = cve.into_boxed();
    query = query.filter(name.ilike("%".to_string() + _name.as_str() + "%" ));
    let record = query.load::<Post>(db_connection).expect("Error loading posts");
    println!("name: {}", record[0].name.clone().unwrap());
    println!("product: {}", record[0].product);
    println!("version: {}", record[0].version);
    println!("description: {}", record[0].description);
    println!("resources: {:?}", record[0].resources);
}
pub fn get_filter(conn: &mut PgConnection, _name: Vec<String>, _description: Vec<String>) -> HashMap<String, String> {
    use diesel::prelude::*;
    use crate::schema::cve::dsl::*;
    let mut query = cve.into_boxed();
    for i in 0.._name.len() {
        let n = "%".to_string() + &_name.clone().into_iter().nth(i).unwrap().trim() + "%";
        query = query.filter(name.ilike(n));
    }
    for i in 0.._description.len() {
        let d = "%".to_string() + &_description.clone().into_iter().nth(i).unwrap().trim() + "%";
        query = query.filter(description.ilike(d));
    }
    let result = query.load::<Post>(conn).expect("Error loading posts");
  //save name and description as a map
    let mut map: std::collections::HashMap<String, String> = std::collections::HashMap::new();
    for i in 0..result.len() {
        map.insert(result[i].name.clone().unwrap(), result[i].description.clone());
    }
    return map;




}

