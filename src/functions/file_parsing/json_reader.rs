
use serde_json;
//TODO: add error handling, add rejection handler
pub mod parser{
pub fn read_json (file_name: &str) -> serde_json::Value {
    let file = std::fs::File::open(file_name).expect("file should open read only");
    let reader = std::io::BufReader::new(file);
    let mut v: serde_json::Value = serde_json::from_reader(reader).expect("file should be proper JSON");

    return v;
}
    pub fn get_nested_json (json: serde_json::Value, key: &str) -> serde_json::Value {
        if json.is_null(){
            return serde_json::from_str("{}").unwrap();
        }
        else {
            let map: std::collections::HashMap<String, serde_json::Value> = serde_json::from_value(json).unwrap();
            let nested_json = map.get(key).is_some().then(|| map.get(key).unwrap().to_string());
            return if nested_json.is_none() {
                serde_json::from_str("{}").unwrap()
            } else {
                let nested_json = nested_json.unwrap();
                let nested_json = serde_json::from_str(&nested_json).unwrap();
                nested_json
            }
        }
}

pub fn get_nested_json_array (json: serde_json::Value, key: &str) -> Vec<serde_json::Value> {
    let map: std::collections::HashMap<String, serde_json::Value> = serde_json::from_value(json).unwrap();
    let nested_json = map.get(key).unwrap().to_string();
    let nested_json = serde_json::from_str(&nested_json).unwrap();
    let nested_json: Vec<serde_json::Value> = serde_json::from_value(nested_json).unwrap();
    return nested_json;
}
}
pub mod cve_reader{
    use std::collections::HashMap;
    use crate::functions::file_parsing::json_reader::parser;
    pub fn get_cve(json: serde_json::Value) -> HashMap<String, String>{
        let mut map: std::collections::HashMap<String, String> = std::collections::HashMap::new();
        let containers = parser::get_nested_json(json, "containers");
        let cna = parser::get_nested_json(containers, "cna");
        map.insert("name".to_string(), get_name(cna.clone()));
        map.insert("product".to_string(), get_product(cna.clone()));
        map.insert("version".to_string(), get_version(cna.clone()));
        map.insert("description".to_string(), get_description(cna.clone()));
        return map;
    }
    pub fn get_name(json: serde_json::Value) -> String{
        let x_legacy_v4_record = parser::get_nested_json(json, "x_legacyV4Record");
        let cve_data_meta = parser::get_nested_json(x_legacy_v4_record, "CVE_data_meta");
        let id = parser::get_nested_json(cve_data_meta, "ID");
        return id.to_string();
    }
    pub fn get_product(json: serde_json::Value) -> String{
        let affected = parser::get_nested_json_array(json, "affected");
        let product =  parser::get_nested_json(affected[0].clone(), "product");
        return product.to_string();
    }
    pub fn get_version(json: serde_json::Value) -> String{
        let affected = parser::get_nested_json_array(json, "affected");
        let versions = parser::get_nested_json(affected[0].clone(), "versions");
        let version = parser::get_nested_json(versions[0].clone(), "version");
        return version.to_string();
    }
    pub fn get_description(json: serde_json::Value) -> String{
        let descriptions = parser::get_nested_json_array(json.clone(), "descriptions");
        let description = parser::get_nested_json(descriptions[0].clone(), "value");
        return description.to_string();
    }
    pub fn get_resources(json: serde_json::Value) -> Vec<String>{
        let resources = parser::get_nested_json_array(json, "references");
        let mut resources_vec: Vec<String> = Vec::new();
        for resource in resources{
           let resource = parser::get_nested_json(resource.clone(), "url");
            resources_vec.push(resource.to_string());
        }
        return resources_vec;
    }
}

pub mod data_loader{
    #[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq, Ord, PartialOrd, Eq)]

    struct Data{
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        name: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        product: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        version: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        description: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        resources: Option<Vec<String>>
    }
    use std::fs;
    use std::path::{Path, PathBuf};
    use serde::{Deserialize, Serialize};
    use crate::functions;
    use crate::functions::file_parsing::json_reader::parser;
    use crate::functions::file_parsing::json_reader::cve_reader;

    pub fn load_files(){
        let paths = fs::read_dir("data").unwrap();
        for path in paths {
            let temp = path.unwrap().path();
            let reader = Path::new(temp.to_str().unwrap());
            if(reader.is_dir()){
                get_dir(reader.display().to_string());
            }
            else{
                get_files(reader);
            }
        }
    }
    pub fn get_dir(path : String){
        let paths = fs::read_dir(path).unwrap();
        for path in paths {
            let temp = path.unwrap().path();
            let reader = Path::new(temp.to_str().unwrap());
            if(reader.is_dir()){
                println!("Dir: {}", reader.display());
                get_dir(reader.display().to_string());
            }
            else{
                println!("File: {}", reader.display());
                get_files(reader);
            }
        }
    }

    pub fn get_files(path : &Path) {
        let json = parser::read_json(path.to_str().unwrap_or_default());
        if !json.to_string().contains("rejectedReasons") {
            let data = cve_reader::get_cve(json.clone());
            let containers = parser::get_nested_json(json.clone(), "containers");
            let cna = parser::get_nested_json(containers, "cna");
            let cve_data = Data{

                name: Some(data.get("name").is_some().then(|| data.get("name").unwrap().to_string()).unwrap_or_default()),
                product: Some(data.get("product").is_some().then(|| data.get("product").unwrap().to_string()).unwrap_or_default()),
                version: Some(data.get("version").is_some().then(|| data.get("version").unwrap().to_string()).unwrap_or_default()),
                description: Some(data.get("description").is_some().then(|| data.get("description").unwrap().to_string()).unwrap_or_default()),
                resources: Some(cve_reader::get_resources(cna.clone()))
            };


            functions::postgres::postgres_calls::post(cve_data.name.unwrap_or_default(),
                                                      cve_data.product.unwrap_or_default(),
                                                      cve_data.version.unwrap_or_default(),
                                                      cve_data.description.unwrap_or_default(),
                                                      cve_data.resources.unwrap_or_default());
        }
    }
        }

