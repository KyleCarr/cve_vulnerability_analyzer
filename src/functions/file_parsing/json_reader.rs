
use serde_json;
//TODO: add error handling, add rejection handler
pub mod parser{
pub fn read_json (file_name: &str) -> serde_json::Value {
    let file = std::fs::File::open(file_name).expect("file should open read only");
    let reader = std::io::BufReader::new(file);
    let mut v: serde_json::Value = serde_json::from_reader(reader).expect("file should be proper JSON");
    //json_to_map(v.clone());
   // print!("{}", v);
    return v;
}
    pub fn get_nested_json (json: serde_json::Value, key: &str) -> serde_json::Value {
    let map: std::collections::HashMap<String, serde_json::Value> = serde_json::from_value(json).unwrap();
    let nested_json = map.get(key).unwrap().to_string();
    let nested_json = serde_json::from_str(&nested_json).unwrap();
    return nested_json;
}

pub fn get_nested_json_array (json: serde_json::Value, key: &str) -> Vec<serde_json::Value> {
    let map: std::collections::HashMap<String, serde_json::Value> = serde_json::from_value(json).unwrap();
    let nested_json = map.get(key).unwrap().to_string();
    let nested_json = serde_json::from_str(&nested_json).unwrap();
    let nested_json: Vec<serde_json::Value> = serde_json::from_value(nested_json).unwrap();
    return nested_json;
}
}
pub mod cve_reader{
    use std::collections::HashMap;
    use crate::functions::file_parsing::json_reader::parser;
    pub fn get_cve(json: serde_json::Value) -> HashMap<String, String>{
        let mut map: std::collections::HashMap<String, String> = std::collections::HashMap::new();
        let containers = parser::get_nested_json(json, "containers");
        let cna = parser::get_nested_json(containers, "cna");
        map.insert("name".to_string(), get_name(cna.clone()));
        map.insert("product".to_string(), get_product(cna.clone()));
        map.insert("version".to_string(), get_version(cna.clone()));
        map.insert("description".to_string(), get_description(cna.clone()));
        return map;
    }
    pub fn get_name(json: serde_json::Value) -> String{
        let x_legacy_v4_record = parser::get_nested_json(json, "x_legacyV4Record");
        let cve_data_meta = parser::get_nested_json(x_legacy_v4_record, "CVE_data_meta");
        let id = parser::get_nested_json(cve_data_meta, "ID");
        return id.to_string();
    }
    pub fn get_product(json: serde_json::Value) -> String{
        let affected = parser::get_nested_json_array(json, "affected");
        let product =  parser::get_nested_json(affected[0].clone(), "product");
        return product.to_string();
    }
    pub fn get_version(json: serde_json::Value) -> String{
        let affected = parser::get_nested_json_array(json, "affected");
        let versions = parser::get_nested_json(affected[0].clone(), "versions");
        let version = parser::get_nested_json(versions[0].clone(), "version");
        return version.to_string();
    }
    pub fn get_description(json: serde_json::Value) -> String{
        let descriptions = parser::get_nested_json_array(json.clone(), "descriptions");
        let description = parser::get_nested_json(descriptions[0].clone(), "value");
        return description.to_string();
    }
    pub fn get_resources(json: serde_json::Value) -> Vec<String>{
        let resources = parser::get_nested_json_array(json, "references");
        let mut resources_vec: Vec<String> = Vec::new();
        for resource in resources{
           let resource = parser::get_nested_json(resource.clone(), "url");
            resources_vec.push(resource.to_string());
        }
        return resources_vec;
    }
}

pub mod data_loader{
    use std::fs;
    use std::path::{Path, PathBuf};
    use crate::functions;
    use crate::functions::file_parsing::json_reader::parser;
    use crate::functions::file_parsing::json_reader::cve_reader;

    pub fn load_files(){
        let paths = fs::read_dir("/home/kyle/Documents/code/rust/cve_vulnerability_analyzer/cvelistV5-main/cves/").unwrap();
        for path in paths {
            let temp = path.unwrap().path();
            let reader = Path::new(temp.to_str().unwrap());
            if(reader.is_dir()){
                get_dir(reader.display().to_string());
            }
            else{
                get_files(reader);
            }
        }
    }
    pub fn get_dir(path : String){
        let paths = fs::read_dir(path).unwrap();
        for path in paths {
            let temp = path.unwrap().path();
            let reader = Path::new(temp.to_str().unwrap());
            if(reader.is_dir()){
                println!("Dir: {}", reader.display());
                get_dir(reader.display().to_string());
            }
            else{
                println!("File: {}", reader.display());
                get_files(reader);
            }
        }
    }

    pub fn get_files(path : &Path){
        let json = parser::read_json(path.to_str().unwrap());
        let data = cve_reader::get_cve(json.clone());
        let containers = parser::get_nested_json(json.clone(), "containers");
        let cna = parser::get_nested_json(containers, "cna");
        let name = data.get("name").unwrap().to_string();
        let product = data.get("product").unwrap().to_string();
        let version = data.get("version").unwrap().to_string();
        let description = data.get("description").unwrap().to_string();
        let resources = cve_reader::get_resources(cna.clone());
        functions::postgres::postgres_calls::post( name, product, version, description, resources);
            }
        }

